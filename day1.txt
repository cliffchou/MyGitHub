1.所有的版本控制系统只能跟踪文本文件的改动，比如TXT文件、网页，所有的程序代码等等，Git也不例外。因此，对于图片、视屏这些二进制文件，虽然也能由版本控制
  系统管理，但是没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是说只知道每次图片从100KB改成了120KB，但是具体改了啥也不清楚。不信的是，Microsoft的word格式就是二进制的，因此
  版本控制系统没法跟踪Word文件的改动。因此，若要真正使用版本控制系统，就要以纯文本方式编写文件。
  注意：Windows为了保存UTF-8编码的文件，在每个文件开头添加了0xefbbbf(十六进制)的字符，会有很多问题，比如网页第一行可能会显示一个“？”，明明正确的程序一编译就报语法错误

2.初始化一个Git仓库：git init

3.写好的文件要放在你建好的Git仓库所对应的目录下（或子目录），否则Git无法找到该文件，而把一个文件放到Git只需要两不：
  1）$ git add 文件名
  2）$ git commit -m "操作提示名"---->-m后为本次提交的说明，最好是有意义的内容
  注意：commit一次可以提交很多文件，所以你可以多次add不同的文件，然后一起提交

4.git status 查看仓库当前的状态
  git diff 文件名： 查看文件上一次具体的修改内容
        ===>>git diff #是Workdict与stage的比较（还没有添加的文件！！！先查看修改的地方，而后才可以放心 add ！！！）
             git diff --cached #是stage和master（分支的比较，也即是还没有提交的文件（但是已经添加了），也是先看看修改的地方，然后才可以放心提交！！！）
             注意：第一次修改的readme.txt文件add并commit后，根据廖老师上面说的图谱来看，暂存区应该是空的，再次修改readme.txt文件后，执行git diff readme.txt。此时工作区有修改，而暂存区是还没被add，没有修改，可以看作是空的，所以执行结果是有被修改了

  git log 显示从最近到最远的提交日志，倘若嫌弃输出太多以至于眼花缭乱，可以加上 --pretty=online参数
 
5.如果git命令输完后不返回，或者出现<END>标记，那么输入 :q 即可

6.返回到以前的版本：
  1）HEAD 指向的版本就是当前版本（正因如此，允许我们在历史的版本中穿梭），HEAD^ 上一个版本，HEAD^^ 上上个版本，...，HEAD~100 往上100个版本
  2）git reset --hard HEAD^  退回到上一个版本（指的是仓库中的文件退回到上一个版本，really）

##退回到上个版本后，如何回来？
  只要命令行窗口没有关闭，顺着上去就可以找到需要的那个版本的commit版本号(不用写全，找到就行，但是也不能少写，不然重了就不好确定是哪个版本了)，再次利用上述命令乘上时光鸡就可以回来了
  git reset --hard 3628164

##可是万一撒币了，关了电脑怎么办？
  若想使用 $ git reset --hard commit_id 命令回到“未来版本”时，必须找到该版本对应的commit id。可以使用
  git reflog 命令用来记录你的每一次命令

7.Working Directory（工作区）：就是电脑里能看到的目录
  Repository（版本库）：工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库。里面存了很多重要的东西，最重要的为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master（唯一的），以及指向master的一个指针叫HEAD。
  ----->往库里添加文件，第一步：git add 其实把文件添加到了暂存区；第二步：git commit其实把暂存区的所有内容提交到当前分支

8.git checkout filename：丢弃在工作区的修改
  1）add添加之前，文件自修改后还没有被放入暂存区，撤销后就回到和版本库一模一样的状态；
  2）add之后，已经将文件添加到了暂存区，而且现在又对工作区作了修改，撤销后就回到了暂存区之中的状态
  总而言之，回到最近一次git commit或git add的状态
  注意：-- 很重要，没有这个符号就表示切换到另一个分支

==>如果已经将上面的“胡话”git add 到暂存区了，则利用
   git reset HEAD file ：可以把暂存区的修改给撤销掉（unstage），重新放回工作区

==>倘若已经将“胡话”从暂存区提交到了版本库，可以通过版本回退到上一个版本。不过前提是，你还没有把自己的本地版本库推送到远程。



























